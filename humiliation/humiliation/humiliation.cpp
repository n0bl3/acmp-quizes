/*
 * Издевательство
 * (Время: 1 сек. Память: 16 Мб Сложность: 28%)
 * Штирлиц ехал на машине, увидел голосующего Бормана, и проехал мимо. 
 * Через некоторое время он снова увидел голосующего Бормана, и снова 
 * проехал мимо. Вскоре он опять увидел голосующего Бормана.
 * - Издевается! - подумал Борман.
 * - Кольцевая! - догадался Штирлиц.
 * В городе N площадей. Любые две площади соединены между собой ровно 
 * одной дорогой с двусторонним движением. В этом городе живет Штирлиц. 
 * У Штирлица есть хобби - он любит воскресным утром выйти из дома, 
 * сесть в машину, выбрать какой-нибудь кольцевой маршрут, проходящий 
 * ровно по трем площадям (то есть сначала он едет с какой-то площади 
 * на какую-то другую, потом - на третью, затем возвращается на начальную, 
 * и опять едет по этому маршруту). Он воображает, что где-то на этом 
 * пути стоит Борман. И так вот ездит Штирлиц все воскресенье, пока 
 * голова не закружится, и радуется...
 * 
 * Естественно, что Штирлицу хочется проезжать мимо точки, в которой, 
 * как он воображает, стоит Борман, как можно чаще. Для этого, естественно, 
 * выбранный Штирлицем маршрут должен быть как можно короче. Напишите 
 * программу, которая выберет оптимальный для Штирлица маршрут.
 * 
 * Входные данные
 * 
 * Во входном файле INPUT.TXT записано сначала число N (3 <= N <= 100), 
 * а затем матрица NxN расстояний между площадями (число в позиции i,j 
 * обозначает длину дороги, соединяющей i-ую и j-ую площади). Все числа 
 * в матрице (кроме стоящих на главной диагонали) - натуральные, не 
 * превышающие 1000. Матрица симметрична относительно главной диагонали, 
 * на главной диагонали стоят 0.
 * 
 * Выходные данные
 * 
 * В выходной файл OUTPUT.TXT выведите длину оптимального маршрута.
 * */


#include <fstream>
#include <vector>
#include <limits>

#define INPUT "INPUT.TXT"
#define OUTPUT "OUTPUT.TXT"

class humiliation {
public:
    humiliation() :
    N(0),
    N_SQUARED(0),
    best_route_len(std::numeric_limits<int>::max())
    {
        get_input();
        solve();
        save_output();
    }

    void get_input(void) {
        std::ifstream in(INPUT);

        if(in.is_open()) {
            in >> N;
            N_SQUARED = N*N;

            m_adj_matr.assign(N_SQUARED, 0);

            for(int i = 0; i < N_SQUARED; i++) {
                in >> m_adj_matr[i];
            }

            in.close();
        }
    }

    void solve(void) 
    {
        int sum = 0;

        // выведено опытным путем :)
        for(int k = 0; k < N-2; k++) {
            for(int i = k+1; i < N-1; i++) {
                for(int j = i+1; j < N; j++) {
                    sum = m_adj_matr[k*N+i] + m_adj_matr[k*N+j] + m_adj_matr[i*N+j];

                    if(sum < best_route_len) best_route_len = sum;
                }
            }
        }
    }

    void save_output(void) 
    {
        std::ofstream out(OUTPUT);

        if(out.is_open()) {
            out << best_route_len;
            out.close();
        }
    }

private:
    int N;
    int N_SQUARED;
    int best_route_len;

    std::vector<int> m_adj_matr;
};

int main(int argc, char **argv)
{
    humiliation obj;

    return 0;
}